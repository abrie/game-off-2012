<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>test</title>

	<link href="styles.css" rel="stylesheet" type="text/css" />
	<script>
		var createjs = window;
	</script>
	<script type="text/javascript" src="lib/easeljs-0.5.0.min.js"></script>
	<script type="text/javascript" src="lib/underscore-min.js"></script>

	<script>
	var FOOT1 = 1, FOOT2 = 2, FOOT3 = 3, STAND = 4;
	var keyMap = {76:FOOT1, 75:FOOT2, 74:FOOT3, 72:STAND};

	var intentionSequence = [];
	function newIntentionSequence() {
		intentionSequence.length = 0;
	}

	var currentIntention = [];
	function newIntention() {
		intentionSequence.push(currentIntention);
		currentIntention = [];
		
	}

	function addIntentionToSequence() {
		if (currentIntention.length > 0) {
			newIntention();
		}
	}

	function mostRecentIntention() {
		if (currentIntention.length >= 1 ) {
			return currentIntention;
		}
		else if (intentionSequence.length >= 1) {
			return intentionSequence[ intentionSequence.length-1 ];
		}
		else {
			return undefined;
		}
	}

	var ACTION_STEP_FORWARD = 1;
	var ACTION_STEP_BACKWARD = 2;
	var ACTION_STAND = 3;
	var ACTION_NOTHING = 0;
	function evaluateIntentionSequence() {
		var lastIntention = mostRecentIntention();
		var result = ACTION_NOTHING;
		if(lastIntention) {
			if (_.contains(lastIntention, FOOT3)) {
				playerSprite.gotoAndPlay("step3");		
				if(intentionSequence.length == 3) { // all the steps are on seperate frames
					if( _.contains(intentionSequence[0], FOOT1) &&
						_.contains(intentionSequence[1], FOOT2) &&
						_.contains(intentionSequence[2], FOOT3)) 
						result = ACTION_STEP_FORWARD;
					newIntentionSequence();
				}
				else if(intentionSequence.length > 1) {
					newIntentionSequence();
					currentIntention.push(FOOT3);
				}
			}
			else if (_.contains(lastIntention, FOOT2)) {
				playerSprite.gotoAndPlay("step2");		
			}
			else if(_.contains(lastIntention, FOOT1)) {
				playerSprite.gotoAndPlay("step1");		
				if(intentionSequence.length == 3) { // all the steps are on seperate frames
					if( _.contains(intentionSequence[0], FOOT3) &&
						_.contains(intentionSequence[1], FOOT2) &&
						_.contains(intentionSequence[2], FOOT1)) 
						result = ACTION_STEP_BACKWARD;
					newIntentionSequence();
				}
				else if(intentionSequence.length > 1) {
					newIntentionSequence();
					currentIntention.push(FOOT1);
				}
			}
			else if(_.contains(lastIntention, STAND)) {
				result = ACTION_STAND;
				newIntentionSequence();
			}
		}
		return result;
	}

	function onKeyDown(keyCode) {
		var mapped = keyMap[keyCode];
		if (mapped) {
			currentIntention.push(mapped);
            soundOn(mapped,3);
			return false;
		}
	}

	function handleKeyDown(e) {
		//cross browser issues exist, says EaselJS
		if(!e){ var e = window.event; }
		return onKeyDown(e.keyCode);
	}

	function handleKeyUp(e) {
		return;
	}

	var player = {pX:500,pY:100,tX:500,tY:100}
	function initPlayer() {
		var playerSpriteParameters = {
			images: ["assets/chin.png"],
			frames: {count:5, width:150, height:100, regX:75, regY:50},
			animations: {
				stand: {frames:[1,0], next:false, frequency:3},
				step1: {frames:[2], next:false, frequency:1 },
				step2: {frames:[3], next:false, frequency:1 },
				step3: {frames:[3,4], next:"land", frequency:1 },
				land: {frames:[4,3,2], next:false, frequency:2},
			}
		};
		var spriteSheet  = new createjs.SpriteSheet(playerSpriteParameters);
		if (!spriteSheet.complete) {
			    spriteSheet.onComplete = function() { console.log("complete..."); generatePlayerSpriteAnimation(spriteSheet); }
		}
		else {
			generatePlayerSpriteAnimation( spriteSheet );
		}
	}
	var playerSprite = undefined;
	function generatePlayerSpriteAnimation( spriteSheet ) {
		playerSprite = new createjs.BitmapAnimation(spriteSheet);
		playerSprite.gotoAndPlay("step1");		
		playerSprite.x = player.pX;
		playerSprite.y = player.pY;
		stage.addChild(playerSprite);
	}

	var stage = undefined;
	var audio_context = undefined;
	function init() {
		try {
			audio_context = new (window.AudioContext || window.webkitAudioContext);
		} catch (e) {
			alert('There is no audio oscillator support in this browser');
		}
		initFrequencyMap();
		initOscillators();
		document.onkeydown = handleKeyDown;
		document.onkeyup = handleKeyUp;
		var canvas = document.getElementById("testCanvas");

		stage = new Stage(canvas);
		initPlayer();

		stage.update();
		Ticker.setFPS(20);
		Ticker.useRAF = true;
		Ticker.addListener(window);
	}

	var frequencyMap = {};
	function initFrequencyMap() {
		frequencyMap[FOOT1] = 261.63;
		frequencyMap[FOOT2] = 329.63;
		frequencyMap[FOOT3] = 392;
		frequencyMap[STAND] = 400;
	}

	function newOscillator( id, duration ) {
		var result = {
			id: id,
			duration: duration,
			volumeNode: audio_context.createGainNode(),
			o : undefined,
			createOscillator : function() {
				this.duration = duration;
				this.o = audio_context.createOscillator();
				this.o.frequency.value = frequencyMap[id];
				this.o.connect(this.volumeNode);
			},
			initialize : function() {
				this.volumeNode.connect(audio_context.destination);
				this.createOscillator();
			},
			active : false,
			start : function() {
				if (this.active)
					return;
				this.volumeNode.gain.value = 1.0;
				this.active = true;
				this.o.noteOn(0);
			},
			stop : function() {
				if (!this.active)
					return;
				this.volumeNode.gain.value = 0.0;
				this.o.noteOff(audio_context.currentTime+0.01);
				this.active = false;
				this.needsReset = true;
			},
			needsReset:false,
			reset : function() {
				this.o.disconnect();
				this.o = undefined;
				this.createOscillator();
				this.needsReset = false;
			},
			advance : function() {
				if (this.needsReset) {
					this.reset();
				}
				else if(this.active) {
					this.duration--;
					if (this.duration == 0) {
						this.stop();
					}
				}
			},
		}
		result.initialize();
		return result;
	}

	var oscillators = {}
	function initOscillators() {
		oscillators[FOOT1] = newOscillator(FOOT1, 3);
		oscillators[FOOT2] = newOscillator(FOOT2, 3);
		oscillators[FOOT3] = newOscillator(FOOT3, 3);
		oscillators[STAND] = newOscillator(STAND, 3);
	}

	function soundOn(which, length) {
		oscillators[which].start();
	}

	function advanceSounds() {
		_.each(oscillators, function(v,k) {
			v.advance();
		});
	}

    function processIntentionSequences() {
		addIntentionToSequence();
		var nextAction = evaluateIntentionSequence();
		if( nextAction != ACTION_NOTHING )
		{
			if( nextAction === ACTION_STEP_FORWARD ) {
				player.tX = player.tX - 50;
			}
			else if( nextAction === ACTION_STEP_BACKWARD ) {
				player.tX = player.tX + 50;
			}
			else if( nextAction === ACTION_STAND ) {
				playerSprite.gotoAndPlay("stand");		
			}
		}
	}

	function tick(elapsedTime) {
		processIntentionSequences();
		advanceSounds();
		if (player.pX != player.tX) {
			player.pX += (player.tX - player.pX)/3 ;
		}
		playerSprite.x = player.pX;
		playerSprite.y = player.pY;
		if (player.tX > stage.canvas.width) { player.tX = 0; }
		if (player.tX < 0) { player.tX = stage.canvas.width; }
		stage.update();
	}
	</script>
</head>
	
<body onload="init();">

	<header id="header" class="EaselJS">
		just playin'
	</header>

	<div class="canvasHolder">
		<canvas id="testCanvas" width="960" height="400"></canvas>
	</div>
</body>
</html>
